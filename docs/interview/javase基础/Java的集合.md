## 1、ArrayList 内部用什么实现的

### 1. 内部数据结构

**（1）底层实现**：Object[] elementData 数组。

**（2）默认容量**：初始容量为 10（首次添加元素时初始化）。

**（3）扩容机制**：当数组容量不足时，按当前容量的 **1.5 倍** 扩容（int newCapacity = oldCapacity + (oldCapacity >> 1)）。

### 2. 核心方法实现原理

**（1）add(E e) 方法**

流程：

1. 检查是否需要扩容：若当前元素数量 size ≥ 数组长度 elementData.length，触发扩容。
2. 扩容：创建新数组（大小为原容量的 1.5 倍），通过 Arrays.copyOf 复制旧数组到新数组。
3. 将新元素插入数组末尾：elementData[size++] = e。

时间复杂度：

- 平均 O(1)（均摊时间复杂度，扩容操作分摊到多次插入中）。

- 最坏 O(n)（触发扩容时需要复制整个数组）。

**（2）add(int index, E element) 方法（指定位置插入）**

流程：

1. 检查索引是否越界。
2. 检查是否需要扩容。
3. 将 index 之后的元素整体右移一位：System.arraycopy(elementData, index, elementData, index + 1, size - index)。
4. 插入新元素：elementData[index] = element。

时间复杂度**：**O(n)（移动元素的开销与插入位置后的元素数量成正比）。

**（3）remove(int index) 方法**

流程：

1. 检查索引是否越界。
2. 获取被删除元素：E oldValue = elementData[index]。
3. 将 index 之后的元素整体左移一位：System.arraycopy(elementData, index + 1, elementData, index, size - index - 1)。
4. 清空末尾引用（避免内存泄漏）：elementData[--size] = null。

时间复杂度**：**O(n)（移动元素的开销与删除位置后的元素数量成正比）。

**（4）clear() 方法**

流程：

1. 遍历数组，将所有元素置为 null（帮助 GC 回收对象）。
2. 重置 size 为 0：size = 0。

**注意**：数组容量 elementData.length 不变，仅清空引用。

时间复杂度**：**O(n)（需遍历数组置空引用）。

### 3. 性能特点

优点：

- **随机访问高效**：通过索引直接访问数组，时间复杂度 O(1)。
- **尾部插入高效**：均摊时间复杂度 O(1)。

缺点：

- **插入/删除中间元素慢**：需移动大量元素（时间复杂度 O(n)）。
- **内存连续分配**：扩容时可能产生内存碎片。

### 4. 使用场景建议

- **适合**：频繁随机访问、尾部插入/删除。
- **不适合**：频繁在中间位置插入/删除（可改用 LinkedList）。

如果需要线程安全，可使用 CopyOnWriteArrayList 或用 Collections.synchronizedList 包装。

## 2、List三个子类的特点

| 特性             | ArrayList          | LinkedList         | Vector               |
| ---------------- | ------------------ | ------------------ | -------------------- |
| **底层结构**     | 动态数组           | 双向链表           | 动态数组             |
| **线程安全**     | 否                 | 否                 | 是（synchronized）   |
| **随机访问性能** | O(1)，快           | O(n)，慢           | O(1)，快             |
| **增删性能**     | 弱                 | 强                 | 弱                   |
| **内存占用**     | 低（数组连续存储） | 高（节点指针占用） | 低（数组连续存储）   |
| **现代替代方案** | 无                 | 无                 | CopyOnWriteArrayList |

## 3、List 和 Map、Set 的区别

#### 1. 核心定义与设计目的

| **集合类型** | **特点描述**                                   | **典型实现类**            |
| ------------ | ---------------------------------------------- | ------------------------- |
| **List**     | **有序集合**，允许重复元素，可通过索引访问元素 | ArrayList, LinkedList |
| **Set**      | **无序集合**，不允许重复元素，保证元素唯一性   | HashSet, TreeSet      |
| **Map**      | **键值对集合**，键唯一，值可重复，通过键访问值 | HashMap, TreeMap      |

#### 2. 核心区别详解

##### **(1) 数据结构与存储方式**

|          | List                                                      | Set                                                  | Map                                                |
| -------- | --------------------------------------------------------- | ---------------------------------------------------- | -------------------------------------------------- |
| 数据结构 | 线性结构，动态数组（如 ArrayList）或链表（如 LinkedList） | 基于哈希表（如 HashSet）或树（如 TreeSet）实现       | 基于哈希表（如 HashMap）或红黑树（如 TreeMap）实现 |
| 存储方式 | 存储元素按插入顺序排列，允许通过 get(index) 随机访问      | 无序存储（LinkedHashSet 例外），重复元素会被自动去重 | 键值对结构，键（Key）唯一，值（Value）可重复       |

##### **(2) 元素唯一性**

| **集合类型** | **唯一性规则**                                   |
| ------------ | ------------------------------------------------ |
| **List**     | 允许重复元素                                     |
| **Set**      | 元素唯一（根据 equals() 和 hashCode() 判断） |
| **Map**      | **键（Key）唯一**，值（Value）可重复             |

##### **(3) 顺序性**

| **集合类型** | **顺序保证**                                                 |
| ------------ | ------------------------------------------------------------ |
| **List**     | 元素按插入顺序保留（有序）                                   |
| **Set**      | 默认无序：<br>HashSet：无序；<br>TreeSet：自然排序或自定义排序；<br>LinkedHashSet：按插入顺序存储。 |
| **Map**      | 默认无序：<br>HashMap：无序；<br>TreeMap：按键自然排序或自定义排序；<br>LinkedHashMap：按插入顺序或访问顺序存储。 |

##### **(4) 元素访问方式**

| List                                                         | Set                                                          | Map                                                          |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 通过索引直接访问（list.get(0)）；<br>支持迭代器（Iterator）和增强for循环遍历。 | **只能通过迭代器**或增强for循环遍历（无索引）；<br>通过 contains(element) 判断元素是否存在。 | 通过键访问值（map.get(key)）；<br>遍历方式包括：<br>（1）遍历键集合（map.keySet()）；<br>（2）遍历值集合（map.values()）；<br>（3）遍历键值对集合（map.entrySet()）。 |

##### **(5) 常见实现类对比**

| **实现类**            | **数据结构**              | **线程安全** | **特点**                         |
| --------------------- | ------------------------- | ------------ | -------------------------------- |
| **ArrayList**         | 动态数组                  | 否           | 随机访问快，增删慢（尾插除外）   |
| **LinkedList**        | 双向链表                  | 否           | 增删快，随机访问慢，支持队列操作 |
| **HashSet**           | 哈希表                    | 否           | 查询效率高，无序                 |
| **TreeSet**           | 红黑树                    | 否           | 元素排序，时间复杂度 O(log n)    |
| **HashMap**           | 数组+链表/红黑树（JDK8+） | 否           | 高效查询，键允许为null           |
| **TreeMap**           | 红黑树                    | 否           | 按键排序，不支持null键           |
| **ConcurrentHashMap** | 分段锁/CAS                | 是           | 高并发场景性能好                 |

##### **(6) 线程安全性**

|                    | List                                                     | Set                                                     | Map                                          |
| ------------------ | -------------------------------------------------------- | ------------------------------------------------------- | -------------------------------------------- |
| 非线程安全的实现类 | ArrayList、LinkedList                                    | HashSet、TreeSet                                        | HashMap、TreeMap                             |
| 线程安全替代方案   | CopyOnWriteArrayList、Collections.synchronizedList(list) | ConcurrentSkipListSet、Collections.synchronizedSet(set) | ConcurrentHashMap、Hashtable（过时，不推荐） |

##### **(7) 性能对比**

| **操作**             | **List（ArrayList）**        | **Set（HashSet）**     | **Map（HashMap）** |
| -------------------- | ---------------------------- | ---------------------- | ------------------ |
| **插入**             | 尾部插入 O(1)，中间插入 O(n) | 平均 O(1)              | O(1)               |
| **删除**             | 尾部删除 O(1)，其他 O(n)     | 平均 O(1)              | O(1)               |
| **查询元素是否存在** | O(n)（需遍历）               | 平均 O(1)              | 根据键查询 O(1)    |
| **内存占用**         | 更低（数组连续存储）         | 中等（哈希表负载因子） | 较高（存储键值对） |

#### 3. 使用场景建议

| List                                                         | Set                                                          | Map                                                          |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 需要保留元素顺序，允许重复；<br>例如：购物车商品列表、分页数据展示。 | 快速判断元素是否存在，去重场景；<br>例如：全局唯一ID池、标签集合。 | 键值映射关系，快速通过键获取值；<br>例如：缓存数据（键为ID，值为对象）、配置参数存储。 |

## 4、Java 中 ArrayList 和 Linkedlist 区别

### 1. 核心区别概览

| **特性**          | **ArrayList**                  | **LinkedList**                |
| ----------------- | ------------------------------ | ----------------------------- |
| **底层数据结构**  | 动态数组                       | 双向链表                      |
| **线程安全**      | 否（需外部同步）               | 否（需外部同步）              |
| **随机访问性能**  | O(1)（基于索引）               | O(n)（需遍历链表）            |
| **插入/删除性能** | 尾插 O(1)，中间或头插平均 O(n) | 头尾插入 O(1)，中间插入 O(n)  |
| **内存占用**      | 更小（连续存储，无指针开销）   | 更大（节点需存储前后指针）    |
| **额外功能**      | 无                             | 实现 Deque，支持队列/栈操作 |

### 2. 底层实现细节

#### 1. ArrayList：

- 基于动态数组，初始容量 **10**，扩容时新容量为 **1.5 倍**（例如旧容量 10 → 新容量 15）。
- **随机访问快**：直接通过索引计算内存偏移地址（如 elementData[index]）。
- **增删代价高**：中间插入或删除需要移动后续元素（使用 System.arraycopy()）。

#### 2. LinkedList：

- 基于 **双向链表**（JDK 1.6 后优化为双向链表，不再是循环链表）。
- 每个节点（Node）包含前驱（prev）和后继（next）指针，以及数据（item）。
- **增删高效**：仅需调整相邻节点的指针（无需数据迁移）。
- **内存碎片化**：节点分散存储，可能影响缓存局部性（Cache Locality）。

### 3. 性能对比

#### (1) 随机访问（get(index)）

```java
// ArrayList
list.get(1000);  // 直接定位到数组索引 1000 的位置 → O(1)

// LinkedList
list.get(1000);  // 需要从头节点或尾节点遍历到第 1000 个节点 → O(n)
```


#### (2) 插入操作

**尾部插入（add(E e)）**：

- **ArrayList**：平均 O(1)（触发扩容时 O(n)）；
- **LinkedList**：直接修改尾指针 → O(1)。

**中间插入（add(int index, E e)）**：

- **ArrayList**：需移动后续元素 → O(n)；
- **LinkedList**：遍历到指定位置后修改指针 → O(n)，优于 ArrayList 的 System.arraycopy？实际在大量数据时可能更慢（遍历耗时）。

#### (3) 删除操作

**尾部删除（removeLast()）**：

- **ArrayList**：直接移除最后一个元素 → O(1)；
- **LinkedList**：修改尾指针 → O(1)。

**中间删除（remove(int index)）**：

- **ArrayList**：需要移动后续元素 → O(n)；
- **LinkedList**：遍历到位置后修改指针 → O(n)，但无数据迁移，实际测试中可能比 ArrayList 更快（特别大数据时）。

### 4. 内存占用分析

#### (1) ArrayList

- **优势**：内存连续，数据存储紧凑，空间利用率高（无指针开销）。
- **碎片风险**：频繁扩容可能导致内存碎片。

#### (2) LinkedList

劣势：

- 每个节点额外存储两个指针（假设为 64 位系统，每个指针占用 8 字节），整体内存占用约为 数据量 × (数据大小 + 16 字节)。
- 内存不连续，可能增加 CPU 缓存未命中（Cache Miss）的概率，降低访问效率。

### 5. 适用场景

**优先选择 ArrayList**：

- 频繁随机访问（如按索引读取）；
- 添加/删除操作主要在尾部进行；
- 内存敏感应用（如移动端）。

**优先选择 LinkedList**：

- 频繁在头部/尾部插入或删除（例如实现队列或栈）；
- 需要高效实现 Deque 操作（如 addFirst(), removeLast()）；
- 数据量较小且对内存不敏感。

### 6. 线程安全与替代方案

1. **默认非线程安全**：多线程环境下同时修改会导致 ConcurrentModificationException。
2. 线程安全替代方案：

- **ArrayList** → CopyOnWriteArrayList（写时复制，适合读多写少）。
- **LinkedList** → 无直接并发替代，可使用 ConcurrentLinkedDeque 或加锁。

## 5、并发集合和普通集合的区别

### 1. 核心区别：线程安全性

- 普通集合（如 ArrayList、HashMap）：

  默认非线程安全，多线程环境下同时修改数据可能导致数据不一致（如 ConcurrentModificationException）或数据覆盖。

  例如：多个线程并发调用 List.add() 可能会导致元素丢失。

- **并发集合（如 ConcurrentHashMap、CopyOnWriteArrayList）**：

  内部通过锁机制、CAS（Compare and Swap）或分段锁（Segment Lock）实现线程安全，直接支持多线程并发操作。

### 2. 实现原理差异

- **普通集合**：
  依赖外部同步（如 Collections.synchronizedList() 或手动加 synchronized 块），但这种全局锁会导致性能下降。

- 并发集合：

  采用更细粒度的锁或无锁算法优化性能：

  **分段锁**（如 ConcurrentHashMap JDK7）：将数据结构分成多个段（Segments），操作不同段时互不阻塞。
  
  **CAS 操作**（如 ConcurrentHashMap JDK8 后改用 CAS + synchronized 细粒度锁）：避免锁竞争，提升并发性能。
  
  **写时复制**（如 CopyOnWriteArrayList）：修改时创建数据副本，读写分离，适合读多写少场景。

### 3. 性能对比

- **普通集合+同步锁**：
  高并发场景下线程竞争激烈，性能低下。
- **并发集合**：
  通过锁优化（如缩小锁粒度）减少竞争，理论上并发性能更高。
  例如：ConcurrentHashMap 的并发度可配置，默认支持 16 个线程同时写。

## 6、HashMap 和 HashTable 有什么区别

| **特性**            | **HashMap**                                                 | **HashTable**                                          |
| ------------------- | ----------------------------------------------------------- | ------------------------------------------------------ |
| **线程安全**        | **非线程安全**（多线程环境下需手动同步）                    | **线程安全**（所有方法用 synchronized 修饰，性能较差） |
| **允许 null 键/值** | **允许**（键和值均可为 null）                               | **不允许**（插入 null 会抛出 NullPointerException）    |
| **继承体系**        | 继承自 AbstractMap                                          | 继承自 Dictionary（遗留类）                            |
| **默认初始容量**    | 16                                                          | 11                                                     |
| **扩容机制**        | 容量翻倍（原大小 ×2，保持 2^n）                             | 容量翻倍 +1（原大小 ×2 +1）                            |
| **哈希冲突处理**    | **数组 + 链表/红黑树**（JDK8+，链表长度 ≥8 转为红黑树）     | **数组 + 链表**（始终链表结构，无法树化）              |
| **迭代器类型**      | **Fail-Fast 迭代器**（快速失败，检测并发修改会抛出异常）    | **安全枚举器**（不快速失败，但已过时）                 |
| **性能**            | **更高**（无同步开销，哈希优化更好）                        | **较低**（同步锁导致多线程竞争频繁）                   |
| **替代方案**        | 多线程推荐 ConcurrentHashMap 或 Collections.synchronizedMap | **遗留类**，现代代码应使用 ConcurrentHashMap 替代      |



## 7、数组和链表的区别

### 1. 存储方式

#### （1）数组：

数组是将元素在内存中连续存储的；

它的优点：因为数据是连续存储的，内存地址连续，所以在查找数据的时候效率比较高；

它的缺点：在存储之前，我们需要申请一块连续的内存空间，并且在编译的时候就必须确定好它的空间的大小。在运行的时候空间的大小是无法随着你的需要进行增加和减少而改变的，当数据两比较大的时候，有可能会出现越界的情况，数据比较小的时候，又有可能会浪费掉内存空间。在改变数据个数时，增加、插入、删除数据效率比较低。

#### （2）链表

链表是动态申请内存空间，不需要像数组需要提前申请好内存的大小，链表只需在用的时候申请就可以，根据需要来动态申请或者删除内存空间，对于数据增加和删除以及插入比数组灵活。

还有就是链表中数据在内存中可以在任意的位置，通过应用来关联数据（就是通过存在元素的指针来联系）

### 2. 应用场景

（1）数组：数据比较少；经常做的运算是按序号访问数据元素；数组更容易实现，任何高级语言都支持；构建的线性表较稳定。

（2）链表：对线性表的长度或者规模难以估计；频繁做插入删除操作；构建动态性比较强的线性表

## 8、Map 中的 key 和 value 可以为 null 么

HashMap 对象的 key、value 值均可为 null。

HahTable 对象的 key、value 值均不可为 null。

且两者的的 key 值均不能重复，若添加 key 相同的键值对，后面的 value 会自动覆盖前面的 value，但不会报错。

## 9、 List a=new ArrayList()和 ArrayList a =new ArrayList()的区别

| **特性**         | **List a = new ArrayList()**                                 | **ArrayList a = new ArrayList()**                      |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------ |
| **变量类型**     | 声明为接口 List                                              | 声明为实现类 ArrayList                                 |
| **多态性**       | 体现面向抽象编程原则（更灵活）                               | 依赖具体实现类（不够灵活）                             |
| **方法调用范围** | 只能访问 List 接口中声明的方法（不可调用ArrayList 特有方法） | 可访问 ArrayList 所有公有方法（包括特有方法）          |
| **代码维护性**   | 后续可无缝切换 List 的其他实现类（如 LinkedList）            | 如果要换实现类，需修改所有声明为 ArrayList 的地方      |
| **扩展性**       | 遵循依赖倒置原则（高层模块不依赖底层具体实现）               | 与具体实现强绑定                                       |
| **设计规范**     | **推荐做法**（符合面向接口编程规范）                         | 仅需特殊场景使用（如必须调用 trimToSize() 等特有方法） |

核心差异代码示例：

```java
// 案例1：List 声明
List<String> list = new ArrayList<>();
list.add("Hello");               // √ List 接口方法
// list.trimToSize();            // × ArrayList 特有方法无法调用（编译报错）

// 案例2：ArrayList 声明
ArrayList<String> arrayList = new ArrayList<>();
arrayList.add("World");          // √ List 接口方法
arrayList.trimToSize();          // √ ArrayList 特有方法可用

```

**场景选择建议**

1. **优先用 List a = new ArrayList()**

**原因**：提高代码扩展性，降低模块间耦合度。

适用场景：

- 需要后续切换其他 List 实现类（如从 ArrayList 改为 LinkedList）时；
- 方法参数或返回值声明为 List，保证通用性；
- 业务逻辑仅依赖 List 基础功能（如 add(), get()）。

2. **慎用 ArrayList a = new ArrayList()**

**原因**：业务代码与具体实现绑定，扩展性差。

适用场景：

- 必须调用 ArrayList 特有方法（如 trimToSize(), ensureCapacity()）时；
- 明确不需要切换列表实现类的特殊场景。
