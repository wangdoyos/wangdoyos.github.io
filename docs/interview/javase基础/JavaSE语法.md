## 1、Java 有没有 goto 语句？

goto 是 Java 中的保留字，在目前版本的 Java 中没有使用。根据 James Gosling（Java 之父）编写的《The Java Programming Language》一书的附录中给出了一个 Java 关键字列表，其中有 goto 和 const，但是这两个是目前无法使用的关键字，因此有些地方将其称之为保留字，其实保留字这个词应该有更广泛的意义，因为熟悉 C 语言的程序员都知道，在系统类库中使用过的有特殊意义的单词或单词的组合都被视为保留字。

## 2、& 和 && 的区别

&运算符有两种用法：(1)按位与；(2)逻辑与。

&&运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true 整个表达式的值才是 true。

&&之所以称为短路运算是因为，如果&&左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&&而不是&，例如在验证用户登录时判定用户名不是 null 而且不是空字符串，应当写为 username != null&&!username.equals("")，二者的顺序不能交换，更不能用&运算符，因为第一个条件如果不成立，根本不能进行字符串的 equals 比较，否则会产生 NullPointerException 异常。

注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。

## 3、在 Java 中，如何跳出当前的多重嵌套循环

在最外层循环前加一个标记如 A，然后用 break A;可以跳出多重循环。（Java 中支持带标签的 break 和 continue 语句，作用有点类似于 C 和 C++中的 goto 语句，但是就像要避免使用 goto 一样，应该避免使用带标签的 break 和 continue，因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用）。

## 4、两个对象值相同 (x.equals(y) == true) ，但却可有不同的 hashCode，这句话对不对

不对，如果两个对象 x 和 y 满足 x.equals(y) == true，它们的哈希码（hashCode）应当相同。

Java 对于 eqauls 方法和 hashCode 方法是这样规定的：

（1）如果两个对象相同（equals 方法返回 true），那么它们的 hashCode 值一定要相同；

（2）如果两个对象的 hashCode 相同，它们并不一定相同。

当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在 Set 集合中，同时增加新元素

的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。

首先 equals 方法必须满足：

（1）自反性：x.equals(x)必须返回 true

（2）对称性：x.equals(y)返回 true 时，y.equals(x)也必须返回 true

（3）传递性：x.equals(y)和 y.equals(z)都返回 true 时，x.equals(z)也必须返回 true

（4）一致性：当x 和 y 引用的对象信息没有被修改时，多次调用 x.equals(y)应该得到同样的返回值。而且对于任何非 null 值的引用 x，x.equals(null)必须返回 false。

实现高质量的 equals 方法的诀窍包括：

（1） 使用==操作符检查"参数是否为这个对象的引用"；

（2）使用 instanceof 操作符检查"参数是否为正确的类型"；

（3）对于类中的关键属性，检查参数传入对象的属性是否与之相匹配；

（4）编写完 equals 方法后，问自己它是否满足对称性、传递性、一致性；

（5）重写 equals 时总是要重写 hashCode；

（6）不要将 equals 方法参数中的 Object 对象替换为其他的类型，在重写时不要忘掉@Override 注解。

## 5、为什么重写equals方法的同时，要重写hashCode方法

如果一个类没有重写equals方法和hashCode方法时，调用这两个方法会调用到来自Object对象的对应方法中：

（1）Object对象的equals方法中，是通过==来判断两个对象是否相等的。

（2）Object对象的hashCode方法会返回调用该方法的对象的地址值作为hash值。

如果我们重写了equals方法，但是没重写hashCode方法，此时当我们想通过自定义类做map的key时就会出现问题：两个属性完全相同的对象，hashCode的值不同，因为这两个对象的地址不同。所以如果把这两个属性相同的对象作为key，它们的value会被存放到map的不同位置中， 这是不合理的。

通过重写hashCode方法，可以让两个属性完全相同的对象返回相同的hashCode，此时再存储到map中时，就不会有问题了。

同样的如果重写了hashCode方法，也要重写equals方法。因为map在存储两个相同hashCode的key时，还会调用equals方法来判断两个key是否相同，如果相同放到一个位置，不同就会放到不同位置。所以如果只重写了hashCode方法没有重写equals方法，一样得不到我们想要的结果。



## 6、是否可以继承 String

String 类是 final 类，不可以被继承。继承 String 本身就是一个错误的行为，对 String 类型最好的重用方式是关联关系（Has-A）和依赖关系（UseA）而不是继承关系（Is-A）。

## 7、当一个对象被当作参数传递到一个方法后，是值传递还是引用传递?

是值传递。Java 语言的方法调用只支持参数的值传递。

当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的。

C++和 C#中可以通过传引用或传输出参数来改变传入的参数的值。说明：Java 中没有传引用实在是非常的不方便，这一点在 Java 8 中仍然没有得到改进，正是如此在 Java 编写的代码中才会出现大量的 Wrapper 类（将需要通过方法调用修改的引用置于一个 Wrapper 类中，再将 Wrapper 对象传入方法），这样的做法只会让代码变得臃肿，尤其是让从 C 和 C++转型为 Java 程序员的开发者无法容忍。

## 8、重载（overload）和重写（override）的区别？

方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。

重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；

重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。

方法重载的规则：

（1）方法名一致，参数列表中参数的顺序，类型，个数不同。

（2）重载与方法的返回值无关，存在于父类和子类，同类中。

（3）可以抛出不同的异常，可以有不同修饰符。

方法重写的规则：

（1）参数列表必须完全与被重写方法的一致，返回类型必须完全与被重写方法的返回类型一致。

（2）构造方法不能被重写，声明为 final 的方法不能被重写，声明为 static 的方法不能被重写，但是能够被再次声明。

（3）访问权限不能比父类中被重写的方法的访问权限更低。

（4）重写的方法能够抛出任何非强制异常（UncheckedException，也叫非运行时异常），无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。

## 9、为什么函数不能根据返回类型来区分重载？

因为调用时不能指定类型信息，编译器不知道你要调用哪个函数

例如：

```java
float max(int a, int b);
int max(int a, int b);
```

当调用 max(1, 2);时无法确定调用的是哪个，单从这一点上来说，仅返回值类型不同的重载是不应该允许的。

再比如对下面这两个方法来说，虽然它们有同样的名字和自变量，但其实是很容易区分的：

```java
void f() {} 
int f() {} 
```

若编译器可根据上下文（语境）明确判断出含义，比如在 int x=f()中，那么这样做完全没有问题。然而，我们也可能调用一个方法，同时忽略返回值，因为我们关心的不是返回值，而是方法调用的其他效果。

所以假如我们像下面这样调用方法： 

```java
f(); 
```

Java 怎样判断 f()的具体调用方式呢？而且别人如何识别并理解代码呢？由于存在这一类的问题，所以不能。

函数的返回值只是作为函数运行之后的一个“状态”，他是保持方法的调用者与被调用者进行通信的关键。并不能作为某个方法的“标识”。

## 10、char 型变量中能不能存储一个中文汉字，为什么？

char 类型可以存储一个中文汉字，因为 Java 中使用的编码是 Unicode（不选择任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法），一个 char 类型占 2 个字节（16 比特），所以放一个中文是没问题的。

?>**补充**：使用 Unicode 意味着字符在 JVM 内部和外部有不同的表现形式，在 JVM 内部都是 Unicode，当这个字符被从 JVM 内部转移到外部时（例如存入文件系统中），需要进行编码转换。所以 Java 中有字节流和字符流，以及在字符流和字节流之间进行转换的转换流，如 InputStreamReader 和 OutputStreamReader，这两个类是字节流和字符流之间的适配器类，承担了编码转换的任务；

## 11、抽象类(abstract class)和接口(interface)有什么异同？

|        | 不同点                                                       |
| ------ | ------------------------------------------------------------ |
| 抽象类 | 1、抽象类中可以定义构造器<br>2、可以有抽象方法和具体方法<br>3、抽象类中的成员可以是 private、默认、protected、public<br/>4、抽象类中可以定义成员变量<br>5、有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法<br>6、抽象类中可以包含静态方法<br>7、一个类只能继承一个抽象类 |
| 接口   | 1、接口中不能定义构造器<br>2、方法全部都是抽象方法<br>3、接口中的成员全都是 public 的<br/>4、接口中定义的成员变量实际上都是常量<br>5、接口中不能有静态方法<br>6、一个类可以实现多个接口 |

相同点：

1、不能够实例化<br/>2、可以将抽象类和接口类型作为引用类型<br>3、一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类

## 12、抽象的(abstract)方法是否可同时是静态的(static), 是否可同时是本地方法(native)，是否可同时被 synchronized

都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。

本地方法是由本地代码（如 C 代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。

synchronized 和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。

## 13、阐述静态变量和实例变量的区别？

**静态变量:** 是被 static 修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；静态变量可以实现让多个对象共享内存。

**实例变量:** 必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。

## 14、==和 equals 的区别？

equals 和== 最大的区别是一个是方法一个是运算符。

==：如果比较的对象是基本数据类型，则比较的是数值是否相等；如果比较的是引用数据类型，则比较的是对象的地址值是否相等。

equals()：用来比较方法两个对象的内容是否相等。

?>注意：equals 方法不能用于基本数据类型的变量，如果没有对 equals 方法进行重写，则比较的是引用类型的变量所指向的对象的地址。

## 15、break 和 continue 的区别？

break 和 continue 都是用来控制循环的语句。

break 用于完全结束一个循环，跳出循环体执行循环后面的语句。

continue 用于跳过本次循环，执行下次循环。

## 16、String s = "Hello";s = s + " world!";这两行代码执行后，原始的 String 对象中的内容到底变了没有？

?>没有。因为 String 被设计成不可变(immutable)类，所以它的所有对象都是不可变对象。

在这段代码中，s 原先指向一个 String 对象，内容是 "Hello"，然后我们对 s 进行了“+”操作，那么 s 所指向的那个对象是否发生了改变呢？

答案是没有。这时，s 不指向原来那个对象了，而指向了另一个 String 对象，内容为"Hello world!"，原来那个对象还存在于内存之中，只是 s 这个引用变量不再指向它了。

通过上面的说明，我们很容易导出另一个结论，如果经常对字符串进行各种各样的修改，或者说，不可预见的修改，那么使用 String 来代表字符串的话会引起很大的内存开销。

因为 String 对象建立之后不能再改变，所以对于每一个不同的字符串，都需要一个 String 对象来表示。

这时，应该考虑使用 StringBuffer 类，它允许修改，而不是每个不同的字符串都要生成一个新的对象。并且，这两种类的对象转换十分容易。同时，我们还可以知道，如果要使用内容相同的字符串，不必每次都 new 一个 String。例如我们要在构造器中对一个名叫 s 的 String 引用变量进行初始化，

把它设置为初始值，应当这样做：

```java
public class Demo {
	private String s;
	...
	s = "Initial Value";
	...
}
```

而非

```java
s = new String("Initial Value");
```

后者每次都会调用构造器，生成新对象，性能低下且内存开销大，并且没有意义，因为 String 对象不可改变，所以对于内容相同的字符串，只要一个 String 对象来表示就可以了。

也就说，多次调用上面的构造器创建多个对象，他们的 String 类型属性 s 都指向同一个对象。

?>上面的结论还基于这样一个事实：对于字符串常量，如果内容相同，Java 认为它们代表同一个 String 对象。

而用关键字 new 调用构造器，总是会创建一个新的对象，无论内容是否相同。 

至于为什么要把 String 类设计成不可变类，是它的用途决定的。其实不只 String，很多 Java 标准类库中的类都是不可变的。

在开发一个系统的时候，我们有时候也需要设计不可变类，来传递一组相关的值，这也是面向对象思想的体现。不可变类有一些优点，比如因为它的对象是只读的，所以多线程并发访问也不会有任何问题。当然也有一些缺点，比如每个不同的状态都要一个对象来代表，可能会造成性能上的问题。所以 Java 标准类库还提供了一个可变版本，即 StringBuffer。

## 17、Java 中实现多态的机制是什么？

靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。

程序调用的方法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。